/* Generated By:JJTree: Do not edit this line. ASTElementType.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package javacc;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Vector;

public class ASTElementType extends SimpleNode {
	protected boolean implicit = false;
	protected boolean explicit = false;
	protected boolean optional = false;

	private String[] classes = {
		"UNIVERSAL",
		"CONTEXT",
		"APPLICATION",
		"PRIVATE"
	};

    private final static String[] keywords = {
            "assert",
            "abstract", "boolean", "break", "byte",
            "case", "catch", "char", "class",
            "const", "continue", "default", "do",
            "double", "else", "extends", "final",
            "finally", "float", "for", "goto",
            "if", "implements", "import",
            "instanceof", "int", "interface",
            "long", "native", "new", "package",
            "private", "protected", "public",
            "return", "short", "static", "super",
            "switch", "synchronized", "this",
            "throw", "throws", "transient",
            "try", "void", "volatile", "while"
    };

    /**
     *
     * @param name The current name to be used.
     * @return A sanitized sting that ensures the name does not match a reserved word.
     */
    public String
    sanitizeName( String name )
    {
        // make sure it is not a reserved word
        for (int i = 0; i < keywords.length; ++i) {
            if (name.equals(keywords[i])) {
                name += "Element";
                break;
            }
        }
        return name;
    }

    /**
     * Returns the name of this structured type element.
     *<p>
     * For now, assuming the first identifier child found contains
     * the name;
     */
    public String
    getName()
    {
        int numChildren = jjtGetNumChildren();
        for(int i = 0; i < numChildren; i++)
        {
            SimpleNode n = (SimpleNode)jjtGetChild(i);
            if(n instanceof ASTidentifier)
            {
                return sanitizeName( n.jjtGetFirstToken().image );
            }
        }

        return "ElementType: could not find name!";
    }

    /**
	 * Returns the class name to use for declarations of this
	 * structured type element.
	 *<p>
	 * This assumes there will be a child node of type BuiltinType
	 * or DefinedType.
	 */
	public String
	getClassName()
	{
		int numChildren = jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode n = (SimpleNode)jjtGetChild(i);
			if(n instanceof ASTBuiltinType)
			{
                ASTBuiltinType builtinTypeNode = (ASTBuiltinType)n;
                if (builtinTypeNode.isComposite()) {
                    // Use the name but capitalized
                    String myName = getName();
                    return Character.toUpperCase(myName.charAt(0)) + myName.substring(1);
                } else {
                    return builtinTypeNode.getClassName();
                }
			}
			if(n instanceof ASTDefinedType)
			{
                return getClassNameForDefinedType();
			}
		}

		return "ElementType: could not find class name!";
	}

    /**
     * Returns whether this is a composite element or not by looking for built in types.
     * that are composites.
     */
    public boolean
    isComposite()
    {
        int numChildren = jjtGetNumChildren();
        for(int i = 0; i < numChildren; i++)
        {
            SimpleNode n = (SimpleNode)jjtGetChild(i);
            if(n instanceof ASTBuiltinType)
            {
                return ((ASTBuiltinType)n).isComposite();
            }
        }

        return false;
    }

    public void
	setOptional(boolean optional)
	{
		this.optional = optional;
	}

	public boolean
	isOptional()
	{
		return optional;
	}

	/**
	 * If one of this node's children is a TAGGED builtin type, there is tagging
	 * information present.
	 */
	public boolean
	isTagged()
	{
		int numChildren = jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode n = (SimpleNode)jjtGetChild(i);
			if(n instanceof ASTBuiltinType)
				return ((ASTBuiltinType)n).isTagged();
		}

		return false;
	}

	public int
	getTaggingMethod()
	{
		int numChildren = jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode n = (SimpleNode)jjtGetChild(i);
			if(n instanceof ASTBuiltinType)
				return ((ASTBuiltinType)n).getTaggingMethod();
		}

		// the module default tagging method should be checked here
		System.err.println("ASTElementType.getTaggingMethod: The module default tagging method should have been checked!");
		return ASTTaggedType.IMPLICIT;
	}

	public int
	getTagClass()
	{
		int numChildren = jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode n = (SimpleNode)jjtGetChild(i);
			if(n instanceof ASTBuiltinType)
				return ((ASTBuiltinType)n).getTagClass();
		}

		return ASTTaggedType.CONTEXT;
	}

	public int
	getTagNumber()
	{
		int numChildren = jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode n = (SimpleNode)jjtGetChild(i);
			if(n instanceof ASTBuiltinType)
				return ((ASTBuiltinType)n).getTagNumber();
		}

		return 0;
	}

    private ASTBuiltinType getBuiltInTypeChild() {
        int numChildren = jjtGetNumChildren();
        for(int i = 0; i < numChildren; i++) {
            SimpleNode n = (SimpleNode) jjtGetChild(i);
            if (n instanceof ASTBuiltinType) {
                return (ASTBuiltinType)n;
            }
        }
        return null;
    }

    @Override
    protected boolean generateClassDirectiveText( OutputStream outputStream, String directiveName, StringBuffer line) throws IOException {
        boolean returnValue = false;
        if (directiveName.equals("elementtype"))    // insert a list of declarations
        {
            ASTBuiltinType n = getBuiltInTypeChild();
            String definedClassName = n.getClassNameForElement();
            if (definedClassName == null) {
                definedClassName = getClassName() + "Class";
            }
            int idx = line.indexOf("@");
            String left = line.substring(0, idx);
            int ndx = line.indexOf("@", idx + 1);
            String right = line.substring(ndx + 1);
            // replace the contents
            line.setLength(0);
            line.append(left + definedClassName + right);
            returnValue = true;
        }
        if (directiveName.equals("innerclass"))    // create an inner class since we have something unnamed
        {
            line.setLength(0);
            ASTBuiltinType n = getBuiltInTypeChild();
            // we will only generate an inner class if we are not using a defined type
            if (n.getClassNameDefinedForElement() == null) {
                // the actual element to write is the child of the built in type
                String className = n.getClassNameForElement();
                SimpleNode child = (SimpleNode)n.jjtGetChild(0);
                child.writeInnerClass(outputStream, className);
                line.append( "// end of inner class definition");
            }
            returnValue = true;
        }
        return returnValue;
    }

    @Override
    protected String getInnerClassTemplateName() {
        ASTBuiltinType n = getBuiltInTypeChild();
        String elementType = n.getType().toLowerCase().replace( " ", "" );
        return elementType + "element";
    }

    @Override
    protected Vector<ASTElementType> getElements() {
        // if we are getting elements it means that a child has the actual elements
        ASTBuiltinType n = getBuiltInTypeChild();
        SimpleNode child = (SimpleNode)n.jjtGetChild(0);
        return child.getElements();
    }

  public ASTElementType(int id) {
    super(id);
  }

  public ASTElementType(AsnParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(AsnParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=122cb2cf29c33495d8a88afb0ce8a9f3 (do not edit this line) */
