/* Generated By:JJTree: Do not edit this line. ASTBuiltinType.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package javacc;

import java.io.*;
import java.util.Vector;

public class ASTBuiltinType extends SimpleNode {
	private int builtinType;
    // used in writing the class output files
    private String[] elementDeclarations;
    private String[] constraintDeclarations;
    private String[] methodDeclarations;
    private String constructorText;

    protected static final int INTEGER = 0;
	protected static final int BIT_STRING = 1;
	protected static final int SET = 2;
	protected static final int SEQUENCE = 3;
	protected static final int SET_OF = 4; 
	protected static final int SEQUENCE_OF = 5;
	protected static final int CHOICE = 6;
	protected static final int SELECTION = 7;
	protected static final int TAGGED = 8;
	protected static final int ANY = 9;
	protected static final int ENUM = 10;
	protected static final int OCTET_STRING = 11;
	protected static final int OBJECT_IDENTIFIER = 12;
	protected static final int NULL = 15;
    protected static final int EXTERNAL = 16;
    protected static final int ELLIPSIS = 17;

	private static String typeNames[] = {
		"INTEGER",
		"BIT STRING",
		"SET",
		"SEQUENCE",
		"SET OF",
		"SEQUENCE OF",
		"CHOICE",
		"SELECTION",
		"TAGGED",
		"ANY",
		"ENUM",
		"OCTET STRING",
		"OBJECT IDENTIFIER",
		"REAL",
		"BOOLEAN",
		"NULL"
	};

	private static String classNames[] = {
		"ASN1Integer",
		"BitString",
		"Set",
		"Sequence",
		"SetOf",
		"SequenceOf",
		"Choice",
		"SELECTION",
		"???",
		"Any",
		"ENUM",
		"OctetString",
		"ObjectID",
		"REAL",
		"ASN1Boolean",
		"Null"
	};

	protected String
	getClassName()
	{
		if(builtinType != TAGGED && builtinType != ELLIPSIS)
			return classNames[builtinType];

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getClassName();
		}

		return null;
	}

    /**
     *
     * @return A String of the defined class name for the element.  Returns null
     * if this is not using a defined type.
     */
    public String
    getClassNameDefinedForElement() {
        int numChildren = jjtGetNumChildren();
        for (int i = 0; i < numChildren; i++) {
            SimpleNode n = (SimpleNode) jjtGetChild(i);
            if (n instanceof ASTSetOrSequenceOfType) {
                return n.getClassNameForDefinedType();
            }
        }
        return null;
    }

    /**
     *
     * @return A class name that is used when we define an element that is not a simple type.
     * If there is a composite definition then we will create an inner class to handle it.
     */
    public String
    getClassNameForElement()
    {
        String definedName = getClassNameDefinedForElement();
        if (definedName != null) {
            return definedName;
        }
        // it is not a defined type so we need to go back up to look for the name used
        SimpleNode n = (SimpleNode)jjtGetParent();
        if (n instanceof ASTElementType) {
            // Use the name but capitalized, also add class since we know this is the same as the id
            String myName = ((ASTElementType)n).getName();
            return Character.toUpperCase(myName.charAt(0)) + myName.substring(1) + "Class";
        }
        this.dump("No element name:");
        return "Built In Type: could not find class name for element!";
    }

    protected void
	setType(int type)
	{
		builtinType = type;
	}

	protected String
	getType()
	{
		return typeNames[builtinType];
	}

	/**
	 * Added by Fatih Batuk
	 * <p> to generate Enumerated asn.1 classes in Java
	 * @param enumm ASTEnumeratedType
	 * @param name String
	 * @author Fatih Batuk
	 */
	public void generateClassEnum(ASTEnumeratedType enumm, String name)
	{
        setElementDeclarationsEnum(enumm);
        generateClass(name, "myEnum");
	}

    /**
	 * Added by Fatih Batuk
	 * <p> Creation of elements of the enumerated type
	 * <p>for example : public static final int name = value;
	 * @param enumm
	 * @author Fatih Batuk
	 */
	private void
	setElementDeclarationsEnum(ASTEnumeratedType enumm)
	{
        elementDeclarations = null;

		String eName = "name";
		String eValue = "value";
		
		String dec, dec2;

		Vector<String> decs = new Vector<String>();

		SimpleNode mainNode = (SimpleNode)enumm.jjtGetChild(0);
		
		
		int numChildren = mainNode.jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode element = (SimpleNode)mainNode.jjtGetChild(i);	//take the elements respectively

			SimpleNode nameNode = (SimpleNode)element.jjtGetChild(0);	//element name exists at node 0.
            eName = nameNode.jjtGetFirstToken().image;
            eName = eName.replace('-', '_');

            eValue = Integer.toString(i);  // if an enumeration does not have a number then just use incremental values
            if (element.jjtGetNumChildren() > 1) {
                SimpleNode valueNode = (SimpleNode) element.jjtGetChild(1);    //element value exists at node 1.
                eValue = valueNode.jjtGetFirstToken().image;
                eValue = eValue.replace('-', '_');
            }

			dec = new String("\tpublic static final int " + " " + eName + "_ = " + eValue + ";");
			decs.addElement(dec);
			dec2 = new String("\n\tpublic void setTo_"+eName+"_"+eValue+"() {\n\t\tsetValue("+eName+"_);\n\t}\n");
			decs.addElement(dec2);
		}			
		

		if(decs.size() > 0)
		{
            elementDeclarations = new String[decs.size()];
			decs.toArray(elementDeclarations);
		}
	}

    private void setDeclarationsInteger() {
        /**
         * Added by Fatih Batuk
         * to write INTEGER range constraints like :
         * SomeInteger ::= INTEGER {min (0), max (255)} or
         * MyMinutes ::= INTEGER {first (0), last (59)}
         *
         */

        String constraintName, constraintValue, constraint2Name, constraint2Value;
        String elementStringName, elementStringValue;
        Vector<String> constraintDeclarationList = new Vector<String>();
        Vector<String> methodDeclarationList = new Vector<String>();
        constructorText = "\t\tsuper();";
        int size = -1;
        SimpleNode main = (SimpleNode)jjtGetChild(0);

        SimpleNode element, elementName, elementValue;

        if (main.jjtGetNumChildren() != 0) {

            SimpleNode mainNode = (SimpleNode)main.jjtGetChild(0);
            size = mainNode.jjtGetNumChildren();
            SimpleNode first = (SimpleNode)mainNode.jjtGetChild(0);
            SimpleNode firstName = (SimpleNode)first.jjtGetChild(0);	//M�N OR MAX OR FIRST OR LAST (one of these)
            SimpleNode firstValue = (SimpleNode)first.jjtGetChild(1);	//Its value (it is some number)

            for (int k=0; k<size; k++) {
                element = (SimpleNode)mainNode.jjtGetChild(k);
                elementName = (SimpleNode)element.jjtGetChild(0);	//M�N OR MAX OR FIRST OR LAST (one of these)
                elementValue= (SimpleNode)element.jjtGetChild(1);	//Its value (it is some number)
                elementStringName = elementName.jjtGetFirstToken().image;
                elementStringName = elementStringName.replace('-', '_');
                elementStringValue = elementValue.jjtGetFirstToken().image;
                elementStringValue = elementStringValue.replace('-', '_');
                constraintDeclarationList.add(new String("\tpublic static final long " + " " + elementStringName + " = " + elementStringValue + ";"));
                methodDeclarationList.add(new String("\tpublic void setTo_" + elementStringName + "_" + elementStringValue + "() {\n\t\tsetValue(" + elementStringName + ");\n\t}\n"));
            }
            constraintName = firstName.jjtGetFirstToken().image;
            constraintName = constraintName.replace('-', '_');
            constraintValue = firstValue.jjtGetFirstToken().image;
            constraintValue = constraintValue.replace('-', '_');
            //declarations[0] = "\tpublic static final long " + " " + constraintName + " = " + constraintValue + ";";
            if (size == 1) {
                if (constraintName.equalsIgnoreCase("min") || constraintName.equalsIgnoreCase("first")){
                    //declarations[0] += "\n\tsetMin(" + constraintName +");";
                    constructorText = "\t\tsuper(\"min\"," + constraintName + ");";
                }
                else if (constraintName.equalsIgnoreCase("max") || constraintName.equalsIgnoreCase("last")){
                    //declarations[0] += "\n\tsetMax(" + constraintName +");";
                    constructorText = "\t\tsuper(\"max\"," + constraintName + ");";
                }
            }
            if (size == 2) {

                SimpleNode last = (SimpleNode)mainNode.jjtGetChild(1);
                SimpleNode lastName = (SimpleNode)last.jjtGetChild(0);
                SimpleNode lastValue = (SimpleNode)last.jjtGetChild(1);
                constraint2Name = lastName.jjtGetFirstToken().image;
                constraint2Name = constraint2Name.replace('-', '_');
                constraint2Value = lastValue.jjtGetFirstToken().image;
                constraint2Value = constraint2Value.replace('-', '_');
                //declarations[1] = "\tpublic static final long " + " " + constraint2Name + " = " + constraint2Value + ";";

                if (((constraintName.equalsIgnoreCase("min")||constraintName.equalsIgnoreCase("max")) && (constraint2Name.equalsIgnoreCase("max")||constraint2Name.equalsIgnoreCase("min"))) || ((constraintName.equalsIgnoreCase("first")||constraintName.equalsIgnoreCase("last")) && (constraint2Name.equalsIgnoreCase("last")||constraint2Name.equalsIgnoreCase("first"))))  {

                    if (constraintName.equalsIgnoreCase("min") || constraintName.equalsIgnoreCase("first")){
                        //declarations[0] += "\n\tsetMin(" + constraintName +");";
                        constructorText = "\t\tsuper(\"min\"," + constraintName;
                    }
                    else if (constraintName.equalsIgnoreCase("max") || constraintName.equalsIgnoreCase("last")){
                        //declarations[0] += "\n\tsetMax(" + constraintName +");";
                        constructorText = "\t\tsuper(\"max\"," + constraintName;
                    }

                    if (constraint2Name.equalsIgnoreCase("min") || constraint2Name.equalsIgnoreCase("first")){
                        //declarations[1] += "\n\tsetMin(" + constraint2Name +");";
                        constructorText += ",\"min\"," + constraint2Name + ");";
                    }
                    else if (constraint2Name.equalsIgnoreCase("max") || constraint2Name.equalsIgnoreCase("last")){
                        //declarations[1] += "\n\tsetMax(" + constraint2Name +");";
                        constructorText += ",\"max\"," + constraint2Name + ");";
                    }
                }
            }
            constraintDeclarations = new String[size];
            constraintDeclarationList.toArray(constraintDeclarations);
            methodDeclarations = new String[size];
            methodDeclarationList.toArray(methodDeclarations);

            //else
            //declarations[1]= " ";

            //System.out.println("  ******* SIZE INTEGER is : " + constraintName + " " + constraintValue);
        }
			/*end of checking range constraints*/
    }

        @Override
    protected boolean generateClassDirectiveText( OutputStream outputStream, String directiveName, StringBuffer line) throws IOException {
        boolean returnValue = false;
        if(directiveName.equals("elementsenum"))	// insert a list of declarations
        {
            for(int i = 0; i < elementDeclarations.length; i++)
            {
                outputStream.write(elementDeclarations[i].getBytes());
                outputStream.write(0x0a);
                outputStream.flush();
            }

            line.setLength(0);
            line.append("\t/* end of enumerated constants */");
            returnValue = true;
        }
        if(directiveName.equals("constraints"))	// added by Fatih Batuk
        {									// to write the integer range constraints
            if (constraintDeclarations != null) {
                for (int i = 0; i < constraintDeclarations.length; i++) {
                    outputStream.write(constraintDeclarations[i].getBytes());
                    outputStream.write(0x0a);
                    outputStream.flush();
                }
                line.setLength(0);
                line.append("\t/* end of range constraint constants */");
            } else {
                line.setLength(0);
                line.append("\t/* NO range constraint constants */");
            }
            returnValue = true;
        }
        if(directiveName.equals("methods"))	// added by Fatih Batuk
        {									// to write the integer range constraints
            if (methodDeclarations != null) {
                for(int i = 0; i < methodDeclarations.length; i++)
                {
                    outputStream.write(methodDeclarations[i].getBytes());
                    outputStream.write(0x0a);
                    outputStream.flush();
                }
                line.setLength(0);
                line.append("\t/* end of setters */");
            } else {
                line.setLength(0);
                line.append( "\t/* NO setter methods. */");
            }
            returnValue = true;
        }
        if(directiveName.equals("constructor"))	// added by Fatih Batuk
        {									// to write the integer range constraints in constructor

            outputStream.write(constructorText.getBytes());
            outputStream.flush();
            line.setLength(0);
            returnValue = true;
        }
        return returnValue;
    }

    void
    createClass(String name) {
		/*
		 * Each of the built in type classes and the defined type class should implement a common interface
		 * that has methods for returning class names and generating classes.
		 *
		 * If done, this method will be trivial.
		 */
        if(builtinType == ENUM)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node node = jjtGetChild(i);
                if(node instanceof ASTEnumeratedType != true)
                    continue;
                ASTEnumeratedType et = (ASTEnumeratedType)node;
                generateClassEnum(et,name);
            }
        }
        if(builtinType == SEQUENCE || builtinType == SET)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node n = jjtGetChild(i);
                if(n instanceof SimpleNode != true)
                    continue;

                ((ASTSetOrSequenceType)n).generateClass(name);
            }
        }

        if(builtinType == CHOICE)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node n = jjtGetChild(i);
                if(n instanceof ASTChoiceType != true)
                    continue;

                ((ASTChoiceType)n).generateClass(name);
            }
        }

        if(builtinType == SEQUENCE_OF || builtinType == SET_OF)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node n = jjtGetChild(i);
                if(n instanceof ASTSetOrSequenceOfType != true)
                    continue;

                ((ASTSetOrSequenceOfType)n).generateClass(name);
            }
        }

        if(builtinType == BIT_STRING)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node n = jjtGetChild(i);
                if(n instanceof ASTBitStringType != true)
                    continue;

                ((ASTBitStringType)n).generateClass(name);
            }

            return;
        }

        if(builtinType == OBJECT_IDENTIFIER)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node n = jjtGetChild(i);
                if(n instanceof ASTObjectIdentifierType != true)
                    continue;

                ((ASTObjectIdentifierType)n).generateClass(name);
            }

            return;
        }

        //Added by Fatih Batuk
        if(builtinType == NULL)
        {
            for(int i = 0; i < jjtGetNumChildren(); i++)
            {
                Node n = jjtGetChild(i);
                if(n instanceof ASTNullType != true)
                    continue;

                ((ASTNullType)n).generateClass(name);
            }

            return;
        }

        //added by Fatih Batuk
        if(builtinType == TAGGED)
        {
            // TODO FIXME

			/*
			 * here should be filled correctly if you want to enable creation .java files of TAGGED types like :
			 *
			 * MyInteger ::= [APPLICATION 5] INTEGER
			 * or
			 * MyInteger ::= [5] IMPLICIT INTEGER
			 *
			 * For this example to enable creation of MyInteger.java class
			 */
        }

        String templateName = null;
        if(builtinType == ANY)
        {
            templateName = "any";
        }
        if(builtinType == OCTET_STRING)
        {
            templateName = "octetstring";
        }
        if(builtinType == INTEGER) {
            setDeclarationsInteger();
            templateName = "integer";
        }
        if (templateName != null) {
            generateClass(name, templateName);
        }
    }

    public boolean isComposite() {
        return (builtinType == SEQUENCE || builtinType == SEQUENCE_OF || builtinType == CHOICE);
    }

	public boolean
	isTagged()
	{
		if(builtinType == TAGGED)
			return true;

		return false;
	}

	public int
	getTaggingMethod()
	{
		if(isTagged() != true)
			return 0;	// throw an exception?

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getTaggingMethod();
		}

		return 0;
	}

	public int
	getTagNumber()
	{
		if(isTagged() != true)
			return 0;	// throw an exception?

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getTagNumber();
		}

		return 0;
	}

	public int
	getTagClass()
	{
		if(isTagged() != true)
			return 0;	// throw an exception?

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getTagClass();
		}

		return ASTTaggedType.CONTEXT;
	}

  public ASTBuiltinType(int id) {
    super(id);
  }

  public ASTBuiltinType(AsnParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(AsnParserVisitor visitor, Object data) {

    return
    visitor.visit(this, data);
  }
}
/* JavaCC - OriginalChecksum=52d793b97edd1260735aa5525c834829 (do not edit this line) */
